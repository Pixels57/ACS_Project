#!/usr/bin/env python3
"""
Proof of Concept: TLS Certificate Misconfiguration
Demonstrates certificate validation failures due to misconfigured certificate
"""

import requests
import ssl
import socket
from cryptography import x509
from cryptography.hazmat.backends import default_backend
from datetime import datetime
import sys
import os

# Add backend directory to path for certificate access
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../backend'))

def test_certificate_misconfiguration():
    """
    Test and demonstrate certificate misconfiguration vulnerabilities
    This PoC should be run with the MISCONFIGURED certificate, not the trusted one.
    """
    print("=" * 70)
    print("TLS Certificate Misconfiguration - Proof of Concept")
    print("=" * 70)
    print()
    print("[!] This PoC demonstrates the VULNERABLE misconfigured certificate")
    print("[!] Make sure backend is using generate_misconfigured_cert.py certificate")
    print()
    
    backend_dir = os.path.join(os.path.dirname(__file__), '../../backend')
    cert_path = os.path.join(backend_dir, "cert.pem")
    
    if not os.path.exists(cert_path):
        print("[!] Certificate file not found. Generating misconfigured certificate...")
        try:
            from generate_misconfigured_cert import generate_misconfigured_cert
            os.chdir(backend_dir)
            generate_misconfigured_cert()
            os.chdir(os.path.dirname(__file__))
            print("[+] Misconfigured certificate generated")
        except Exception as e:
            print(f"[ERROR] Failed to generate certificate: {e}")
            print("    Manually run: cd backend && python generate_misconfigured_cert.py")
            return
    
    # Test 1: Read certificate details and identify vulnerabilities
    print("[1] Certificate Details Analysis:")
    print("-" * 70)
    vulnerabilities_found = []
    
    try:
        with open(cert_path, "rb") as f:
            cert = x509.load_pem_x509_certificate(f.read(), default_backend())
        
        print(f"Subject: {cert.subject}")
        print(f"Issuer: {cert.issuer}")
        print(f"Valid from: {cert.not_valid_before}")
        print(f"Valid until: {cert.not_valid_after}")
        
        # Check if expired
        now = datetime.now(cert.not_valid_before.tzinfo)
        if now > cert.not_valid_after:
            print("[VULNERABILITY] ✓ Certificate is EXPIRED!")
            vulnerabilities_found.append("Expired certificate")
        elif now < cert.not_valid_before:
            print("[VULNERABILITY] ✓ Certificate is not yet valid!")
            vulnerabilities_found.append("Certificate not yet valid")
        else:
            print("[OK] Certificate is currently valid (NOT a misconfigured cert)")
        
        # Check Common Name
        cn = None
        for attr in cert.subject:
            if attr.oid == x509.oid.NameOID.COMMON_NAME:
                cn = attr.value
                break
        
        if cn != "localhost":
            print(f"[VULNERABILITY] ✓ Wrong Common Name: {cn} (expected: localhost)")
            vulnerabilities_found.append(f"Wrong CN: {cn}")
        else:
            print(f"[OK] Common Name is correct: {cn} (This is the TRUSTED cert, not misconfigured)")
        
        # Check for SANs
        try:
            san_ext = cert.extensions.get_extension_for_oid(x509.oid.ExtensionOID.SUBJECT_ALTERNATIVE_NAME)
            print(f"[OK] Subject Alternative Names present (This is the TRUSTED cert)")
        except x509.ExtensionNotFound:
            print("[VULNERABILITY] ✓ Missing Subject Alternative Names (SAN)")
            vulnerabilities_found.append("Missing SAN")
        
        # Determine if this is misconfigured or trusted cert
        if not vulnerabilities_found:
            print()
            print("[!] WARNING: This appears to be the TRUSTED certificate, not the misconfigured one!")
            print("[!] To test the vulnerability, use the misconfigured certificate:")
            print("    1. Backup current cert: mv backend/cert.pem backend/cert.pem.backup")
            print("    2. Generate misconfigured: cd backend && python generate_misconfigured_cert.py")
            print("    3. Restart backend server")
            print("    4. Run this PoC again")
            print()
            print("    Or restore misconfigured cert: mv backend/cert.pem.backup backend/cert.pem")
        
    except Exception as e:
        print(f"[ERROR] Failed to read certificate: {e}")
    
    print()
    
    # Test 2: Attempt HTTPS connection with certificate validation
    print("[2] HTTPS Connection Test (with certificate validation):")
    print("-" * 70)
    try:
        response = requests.get('https://localhost:8000', verify=True, timeout=5)
        print("[UNEXPECTED] Connection succeeded - certificate is trusted!")
        print(f"Status code: {response.status_code}")
    except requests.exceptions.SSLError as e:
        print("[EXPECTED] SSL Error (certificate validation failed):")
        print(f"  {type(e).__name__}: {str(e)[:200]}")
        print("[VULNERABILITY] Certificate validation fails - prevents secure connections")
    except requests.exceptions.ConnectionError:
        print("[WARNING] Connection refused - Backend server is not running")
        print("  Start backend: cd backend && python main.py")
    except Exception as e:
        print(f"[ERROR] Unexpected error: {e}")
    
    print()
    
    # Test 3: Connection with verification disabled (demonstrates risk)
    print("[3] HTTPS Connection Test (verification disabled - VULNERABLE):")
    print("-" * 70)
    try:
        response = requests.get('https://localhost:8000', verify=False, timeout=5)
        print("[VULNERABILITY] Connection succeeded with verify=False")
        print("  This demonstrates the risk - users might bypass certificate warnings")
        print(f"  Status code: {response.status_code}")
        print("  WARNING: This bypasses all certificate validation!")
    except requests.exceptions.ConnectionError:
        print("[WARNING] Connection refused - Backend server is not running")
    except Exception as e:
        print(f"[ERROR] {e}")
    
    print()
    
    # Test 4: SSL context validation
    print("[4] SSL Context Validation Test:")
    print("-" * 70)
    try:
        context = ssl.create_default_context()
        with socket.create_connection(('localhost', 8000), timeout=5) as sock:
            try:
                with context.wrap_socket(sock, server_hostname='localhost') as ssock:
                    print("[UNEXPECTED] SSL handshake succeeded - certificate is trusted!")
                    print(f"  Protocol: {ssock.version()}")
            except ssl.SSLError as e:
                print("[EXPECTED] SSL Error (certificate validation failed):")
                print(f"  {type(e).__name__}: {str(e)[:200]}")
                print("[VULNERABILITY] Certificate validation fails at SSL level")
    except ConnectionRefusedError:
        print("[WARNING] Connection refused - Backend server is not running")
    except Exception as e:
        print(f"[ERROR] {e}")
    
    print()
    print("=" * 70)
    print("Summary:")
    print("=" * 70)
    
    if vulnerabilities_found:
        print(f"[VULNERABILITY] Found {len(vulnerabilities_found)} certificate misconfigurations:")
        for vuln in vulnerabilities_found:
            print(f"  - {vuln}")
        print()
        print("The misconfigured certificate causes:")
        print("  - Certificate validation failures")
        print("  - Browser security warnings")
        print("  - Potential for man-in-the-middle attacks")
        print("  - Automated tool failures")
    else:
        print("[INFO] No vulnerabilities detected - certificate appears to be properly configured")
        print("       This PoC is designed to test the MISCONFIGURED certificate.")
        print("       See instructions above to switch to misconfigured certificate.")
    
    print()
    print("Remediation: See issues/REM-003-TLS-Certificate.md")

if __name__ == "__main__":
    test_certificate_misconfiguration()

